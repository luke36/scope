(defsort Expr :import 1 :export 0)
(defsort LetBind :import 1 :export 1)

(defun void :sort Expr)
(defscope void :import ())
(defun var (: x VarUse) :sort Expr)
(defscope var :import ((x 0)))
(defun begin (: e Expr) (: es Expr) :sort Expr)
(defscope begin :import ((e 0) (es 0)))
(defun set! (: x VarUse) (: e Expr) :sort Expr)
(defscope set! :import ((x 0) (e 0)))
(defun let (: b LetBind) (: e Expr) :sort Expr)
(defscope let :import ((b 0) (e 0)) :bind ((e 0) (b 0)))

(defun more-bind (: x VarDef) (: e Expr) (: b LetBind) :sort LetBind)
(defscope more-bind :import ((x 0) (e 0) (b 0)) :export ((x 0) (b 0)))
(defun end-bind :sort LetBind)
(defscope end-bind :import () :export ())

(defsort Stx :import 2 :export 1)
(defun more-rec-bind (: x VarDef) (: e Expr) (: b Stx) :sort Stx)
(defun end-rec-bind :sort Stx)
(defun letrec (: b Stx) (: e Expr) :sort Expr)

(defun extracting (: b Stx) (: voids LetBind)
                  (: set Expr) (: body Expr)
                  :sort Expr)
(defmacro (letrec 1 2) (extracting 1 (end-bind) (void) 2))
(defmacro (extracting (more-rec-bind 1 2 3) 4 5 6)
          (extracting 3 (more-bind 1 (void) 4)
                      (begin (set! (->use 1) 2) 5) 6))
(defmacro (extracting (end-rec-bind) 1 2 3)
          (let 1 (begin 2 3)))

(infer)
(dump)
(regexp void var begin set! let more-bind end-bind letrec more-rec-bind end-rec-bind)
(exit)
